<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 欧拉烟雾模拟 - 全参数增强版</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <style>
        /* 背景保持黑色，由于渲染器设为透明，canvas 会透出 body 的背景色 */
        body { margin: 0; overflow: hidden; background-color: #050000; font-family: 'Segoe UI', system-ui, sans-serif; }
        
        #ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #ff4444;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
        }

        #controls-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(15, 15, 15, 0.9);
            padding: 20px;
            border-radius: 12px;
            color: white;
            width: 320px;
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(15px);
            display: flex; flex-direction: column; gap: 10px;
            max-height: 90vh; overflow-y: auto; z-index: 100;
        }

        .control-group { display: flex; flex-direction: column; gap: 4px; }
        .control-group label { font-size: 0.75em; opacity: 0.7; display: flex; justify-content: space-between; }
        .control-group input[type="range"] { width: 100%; cursor: pointer; }
        .control-group input[type="number"], .control-group select { 
            background: rgba(0,0,0,0.4); border: 1px solid #444; color: #fff; 
            padding: 5px; border-radius: 4px; font-size: 0.85em; outline: none;
        }
        
        .btn-row { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
        button { 
            cursor: pointer; background: #dc2626; font-weight: bold; border: none; 
            color: white; padding: 10px; border-radius: 6px; font-size: 0.85em; transition: background 0.2s;
        }
        button:hover { background: #b91c1c; }
        button.secondary { background: #444; }
        button.secondary:hover { background: #555; }
        button.accent { background: #2563eb; }
        button.accent:hover { background: #1d4ed8; }

        #debug-stats {
            position: absolute; bottom: 20px; left: 20px; background: rgba(0, 0, 0, 0.8);
            color: #0f0; padding: 12px; font-family: 'Consolas', monospace; font-size: 11px;
            border-radius: 6px; border: 1px solid #0f0; pointer-events: none;
        }

        .endo-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            border: 30px solid black; border-radius: 50%; box-sizing: border-box;
            box-shadow: inset 0 0 250px black; opacity: 0.85;
        }
        .hint { position: absolute; bottom: 20px; right: 350px; color: rgba(255,255,255,0.5); font-size: 0.8em; pointer-events: none; }
        
        #status-msg {
            font-size: 0.7em; color: #facc15; margin: 4px 0; text-align: center; display: none;
        }
    </style>
</head>
<body>
    <div class="endo-overlay"></div>


    <div id="debug-stats">
        状态: <span id="val-status">运行中</span><br>
        当前分辨率: <span id="val-curr-res">32³</span><br>
        计算耗时: <span id="val-ms">0</span> ms/step<br>
        密度峰值: <span id="val-max-d">0.0</span>
    </div>

    <div class="hint">左键旋转视角 | 滚轮缩放</div>

    <div id="controls-panel">
        <div class="control-group">
            <label>计算网格分辨率 (Grid Res) <span>⚠️重置物理场</span></label>
            <select id="inp-res">
                <option value="16">16 x 16 x 16 (极速)</option>
                <option value="32" selected>32 x 32 x 32 (标准)</option>
                <option value="48">48 x 48 x 48 (精细)</option>
                <option value="64">64 x 64 x 64 (高精-需强力CPU)</option>
            </select>
        </div>

        <hr style="opacity:0.1; border:none; border-top:1px solid #fff;">

        <div class="control-group">
            <label>涡流增强 (Vorticity) <span id="lbl-vort">5.000</span></label>
            <input type="range" id="inp-vort" min="0" max="10" step="0.1" value="5">
        </div>
        <div class="control-group">
            <label>垂直浮力 (Rising) <span id="lbl-buoyancy">0.60</span></label>
            <input type="range" id="inp-buoyancy" min="0" max="1" step="0.01" value="0.6">
        </div>
        <div class="control-group">
            <label>横向扩散 (Diffusion) <span id="lbl-diff">0.08</span></label>
            <input type="range" id="inp-diff" min="0" max="1" step="0.01" value="0.08">
        </div>
        <div class="control-group">
            <label>空气扰动 (Turbulence) <span id="lbl-turb">0.90</span></label>
            <input type="range" id="inp-turb" min="0" max="2" step="0.05" value="0.90">
        </div>
        <div class="control-group">
            <label>切割强度 (Source) <span id="lbl-source">30.70</span></label>
            <input type="range" id="inp-source" min="1" max="50" step="0.1" value="30.70">
        </div>
        <div class="control-group">
            <label>烟雾存留度 <span id="lbl-fade">0.999</span></label>
            <input type="range" id="inp-fade" min="0.95" max="1.0" step="0.0001" value="0.9990">
        </div>
        <div class="control-group">
            <label>可视化厚度 (Thickness) <span id="lbl-opacity">0.03</span></label>
            <input type="range" id="inp-opacity" min="0.0" max="2.0" step="0.01" value="0.03">
        </div>

        <hr style="opacity:0.1; border:none; border-top:1px solid #fff;">

        <div class="control-group">
            <label>脱机批量步数</label>
            <input type="number" id="inp-batch-steps" value="100" min="1" max="2000">
            <button id="btn-run-batch" class="accent">执行脱机批量计算</button>
        </div>

        <div class="btn-row">
            <button id="btn-pause" class="secondary">暂停模拟</button>
            <button id="btn-reset">重置物理场</button>
        </div>

        <hr style="opacity:0.1; border:none; border-top:1px solid #fff;">


        <div class="control-group">
            <label>颜色</label>
            <input type="color" id="inp-color" value="#ffffff" style="width:100%; height:30px; border:none; background:none; cursor:pointer;">
        </div>

        <div class="btn-row" style="margin-top:5px;">
            <button id="btn-export" class="secondary" style="font-size:0.7em;">导出 JSON</button>
            <button id="btn-import-trigger" class="secondary" style="font-size:0.7em;">导入 JSON</button>
        </div>
        <input type="file" id="inp-import" accept=".json" style="display: none;">

        <button id="btn-capture" style="background: #22c55e; margin-top:5px;">获取透明投影快照</button>
        <div id="status-msg">状态已更新</div>
    </div>

    <script type="x-shader/x-vertex" id="vertexShader">
        varying vec3 vOrigin;
        varying vec3 vDirection;
        uniform mat4 uInverseModelMatrix;
        void main() {
            vec4 worldPosition = modelMatrix * vec4(position, 1.0);
            vOrigin = (uInverseModelMatrix * vec4(cameraPosition, 1.0)).xyz;
            vDirection = position - vOrigin;
            gl_Position = projectionMatrix * viewMatrix * worldPosition;
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentShader">
        precision highp float;
        precision highp sampler3D;
        varying vec3 vOrigin;
        varying vec3 vDirection;
        uniform sampler3D uDensity;
        uniform vec3 uBaseColor;
        uniform float uOpacity;

        vec2 hitBox(vec3 orig, vec3 dir) {
            vec3 boxMin = vec3(-0.5);
            vec3 boxMax = vec3(0.5);
            vec3 invDir = 1.0 / dir;
            vec3 tmin_tmp = (boxMin - orig) * invDir;
            vec3 tmax_tmp = (boxMax - orig) * invDir;
            vec3 tmin = min(tmin_tmp, tmax_tmp);
            vec3 tmax = max(tmin_tmp, tmax_tmp);
            float t0 = max(tmin.x, max(tmin.y, tmin.z));
            float t1 = min(tmax.x, min(tmax.y, tmax.z));
            return vec2(t0, t1);
        }

        void main() {
            vec3 rayDir = normalize(vDirection);
            vec2 bounds = hitBox(vOrigin, rayDir);
            if (bounds.x > bounds.y || bounds.y < 0.0) discard;

            float t = max(0.0, bounds.x);
            float tMax = bounds.y;
            vec4 sum = vec4(0.0);
            const int steps = 90; 
            float stepSize = (tMax - t) / float(steps);

            for (int i = 0; i < steps; i++) {
                vec3 pos = vOrigin + rayDir * t;
                vec3 texCoord = pos + 0.5;
                float d = texture(uDensity, texCoord).r;

                if (d > 0.0001) {
                    float alpha = smoothstep(0.0, 0.5, d) * uOpacity * stepSize * 45.0;
                    vec4 color = vec4(uBaseColor + d * 0.1, alpha);
                    color.rgb *= color.a;
                    sum += color * (1.0 - sum.a);
                }
                t += stepSize;
                if (sum.a >= 0.98) break;
            }
            if (sum.a < 0.005) discard;
            gl_FragColor = sum;
        }
    </script>

    <script>
        class FluidSolver3D {
            constructor(res) {
                this.res = res;
                this.size = res * res * res;
                this.dt = 0.1;
                this.vorticity = 2.0; this.buoyancy = 0.30; this.fadeRate = 0.999; this.diffusion = 0.40;
                this.sourceIntensity = 10.0; this.turbulence = 0.8; this.absorption = 0.3;
                
                this.density = new Float32Array(this.size);
                this.temp = new Float32Array(this.size); 
                this.u = new Float32Array(this.size); this.v = new Float32Array(this.size); this.w = new Float32Array(this.size); 
                this.uOld = new Float32Array(this.size); this.vOld = new Float32Array(this.size); this.wOld = new Float32Array(this.size);
                this.dOld = new Float32Array(this.size); this.tOld = new Float32Array(this.size);
                this.curlX = new Float32Array(this.size); this.curlY = new Float32Array(this.size); this.curlZ = new Float32Array(this.size); this.curlMag = new Float32Array(this.size);
            }

            IX(x, y, z) {
                x = x < 0 ? 0 : (x >= this.res ? this.res - 1 : x);
                y = y < 0 ? 0 : (y >= this.res ? this.res - 1 : y);
                z = z < 0 ? 0 : (z >= this.res ? this.res - 1 : z);
                return x + y * this.res + z * this.res * this.res;
            }

            step() {
                const res = this.res; const mid = Math.floor(res / 2);
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        const idx = this.IX(mid + i, 1, mid + j);
                        this.density[idx] += this.sourceIntensity; this.temp[idx] += 5.0; 
                        if (this.turbulence > 0) {
                            this.u[idx] += (Math.random() - 0.5) * this.turbulence;
                            this.w[idx] += (Math.random() - 0.5) * this.turbulence;
                        }
                    }
                }
                if (this.vorticity > 0) { this.computeCurl(); this.applyVorticityForce(); }
                for (let i = 0; i < this.size; i++) { this.v[i] += (this.temp[i] * this.buoyancy * 0.05); }
                this.uOld.set(this.u); this.vOld.set(this.v); this.wOld.set(this.w); 
                this.dOld.set(this.density); this.tOld.set(this.temp);
                this.advect(1, this.u, this.uOld, this.uOld, this.vOld, this.wOld);
                this.advect(2, this.v, this.vOld, this.uOld, this.vOld, this.wOld);
                this.advect(3, this.w, this.wOld, this.uOld, this.vOld, this.wOld);
                this.project(this.u, this.v, this.w, this.uOld, this.vOld);
                if (this.diffusion > 0) { this.diffuse(0, this.density, this.dOld, this.diffusion); this.dOld.set(this.density); }
                this.advect(0, this.density, this.dOld, this.u, this.v, this.w);
                this.advect(0, this.temp, this.tOld, this.u, this.v, this.w);
                const factor = 1.0 - this.absorption;
                for (let i = 0; i < res; i++) {
                    for (let j = 0; j < res; j++) {
                        for (let k = 0; k < res; k++) {
                            const idx = i + j * res + k * res * res;
                            if (i === 0 || i === res-1 || j === 0 || j === res-1 || k === 0 || k === res-1) this.density[idx] *= factor;
                            this.density[idx] *= this.fadeRate; this.temp[idx] *= 0.95;
                        }
                    }
                }
            }

            computeCurl() {
                const res = this.res;
                for (let i = 1; i < res - 1; i++) {
                    for (let j = 1; j < res - 1; j++) {
                        for (let k = 1; k < res - 1; k++) {
                            const cx = (this.w[this.IX(i, j+1, k)] - this.w[this.IX(i, j-1, k)] - this.v[this.IX(i, j, k+1)] + this.v[this.IX(i, j, k-1)]) * 0.5;
                            const cy = (this.u[this.IX(i, j, k+1)] - this.u[this.IX(i, j, k-1)] - this.w[this.IX(i+1, j, k)] + this.w[this.IX(i-1, j, k)]) * 0.5;
                            const cz = (this.v[this.IX(i+1, j, k)] - this.v[this.IX(i-1, j, k)] - this.u[this.IX(i, j+1, k)] + this.u[this.IX(i, j-1, k)]) * 0.5;
                            const idx = this.IX(i, j, k);
                            this.curlX[idx] = cx; this.curlY[idx] = cy; this.curlZ[idx] = cz;
                            this.curlMag[idx] = Math.sqrt(cx*cx + cy*cy + cz*cz);
                        }
                    }
                }
            }

            applyVorticityForce() {
                const res = this.res; const eps = this.vorticity;
                for (let i = 2; i < res - 2; i++) {
                    for (let j = 2; j < res - 2; j++) {
                        for (let k = 2; k < res - 2; k++) {
                            const idx = this.IX(i, j, k);
                            let nx = (this.curlMag[this.IX(i+1, j, k)] - this.curlMag[this.IX(i-1, j, k)]) * 0.5;
                            let ny = (this.curlMag[this.IX(i, j+1, k)] - this.curlMag[this.IX(i, j-1, k)]) * 0.5;
                            let nz = (this.curlMag[this.IX(i, j, k+1)] - this.curlMag[this.IX(i, j-1, k)]) * 0.5;
                            const mag = Math.sqrt(nx*nx + ny*ny + nz*nz) + 1e-5;
                            nx /= mag; ny /= mag; nz /= mag;
                            this.u[idx] += eps * (ny * this.curlZ[idx] - nz * this.curlY[idx]) * this.dt;
                            this.v[idx] += eps * (nz * this.curlX[idx] - nx * this.curlZ[idx]) * this.dt;
                            this.w[idx] += eps * (nx * this.curlY[idx] - ny * this.curlX[idx]) * this.dt;
                        }
                    }
                }
            }

            diffuse(b, x, x0, diff) {
                const a = this.dt * diff * this.res;
                for (let n = 0; n < 4; n++) {
                    for (let i = 1; i < this.res - 1; i++) {
                        for (let j = 1; j < this.res - 1; j++) {
                            for (let l = 1; l < this.res - 1; l++) {
                                x[this.IX(i,j,l)] = (x0[this.IX(i,j,l)] + a * (x[this.IX(i+1,j,l)] + x[this.IX(i-1,j,l)] + x[this.IX(i,j+1,l)] + x[this.IX(i,j-1,l)] + x[this.IX(i,j,l+1)] + x[this.IX(i,j,l-1)])) / (1 + 6 * a);
                            }
                        }
                    }
                }
            }

            advect(b, d, d0, u, v, w) {
                const res = this.res; const dt0 = this.dt * (res - 2);
                for (let i = 1; i < res - 1; i++) {
                    for (let j = 1; j < res - 1; j++) {
                        for (let k = 1; k < res - 1; k++) {
                            let x = i - dt0 * u[this.IX(i, j, k)]; let y = j - dt0 * v[this.IX(i, j, k)]; let z = k - dt0 * w[this.IX(i, j, k)];
                            x = Math.max(0.5, Math.min(res - 1.5, x)); y = Math.max(0.5, Math.min(res - 1.5, y)); z = Math.max(0.5, Math.min(res - 1.5, z));
                            const i0 = Math.floor(x), i1 = i0 + 1, j0 = Math.floor(y), j1 = j0 + 1, k0 = Math.floor(z), k1 = k0 + 1;
                            const s1 = x - i0, s0 = 1 - s1, t1 = y - j0, t0 = 1 - t1, u1 = z - k0, u0 = 1 - u1;
                            d[this.IX(i, j, k)] = s0*(t0*(u0*d0[this.IX(i0,j0,k0)] + u1*d0[this.IX(i0,j0,k1)]) + t1*(u0*d0[this.IX(i0,j1,k0)] + u1*d0[this.IX(i0,j1,k1)])) + s1*(t0*(u0*d0[this.IX(i1,j0,k0)] + u1*d0[this.IX(i1,j0,k1)]) + t1*(u0*d0[this.IX(i1,j1,k0)] + u1*d0[this.IX(i1,j1,k1)]));
                        }
                    }
                }
            }

            project(u, v, w, p, div) {
                const res = this.res;
                for (let i = 1; i < res - 1; i++) {
                    for (let j = 1; j < res - 1; j++) {
                        for (let k = 1; k < res - 1; k++) {
                            div[this.IX(i,j,k)] = -0.5*(u[this.IX(i+1,j,k)]-u[this.IX(i-1,j,k)] + v[this.IX(i,j+1,k)]-v[this.IX(i,j-1,k)] + w[this.IX(i,j,k+1)]-w[this.IX(i,j,k-1)])/res; p[this.IX(i,j,k)] = 0;
                        }
                    }
                }
                for (let n = 0; n < 4; n++) {
                    for (let i = 1; i < res - 1; i++) {
                        for (let j = 1; j < res - 1; j++) {
                            for (let k = 1; k < res - 1; k++) {
                                p[this.IX(i,j,k)] = (div[this.IX(i,j,k)] + p[this.IX(i+1,j,k)] + p[this.IX(i-1,j,k)] + p[this.IX(i,j+1,k)] + p[this.IX(i,j-1,k)] + p[this.IX(i,j,k+1)] + p[this.IX(i,j,k-1)]) / 6;
                            }
                        }
                    }
                }
                for (let i = 1; i < res - 1; i++) {
                    for (let j = 1; j < res - 1; j++) {
                        for (let k = 1; k < res - 1; k++) {
                            u[this.IX(i,j,k)] -= 0.5*res*(p[this.IX(i+1,j,k)]-p[this.IX(i-1,j,k)]);
                            v[this.IX(i,j,k)] -= 0.5*res*(p[this.IX(i,j+1,k)]-p[this.IX(i,j-1,k)]);
                            w[this.IX(i,j,k)] -= 0.5*res*(p[this.IX(i,j+1,k)]-p[this.IX(i,j-1,k)]);
                        }
                    }
                }
            }

            reset() { this.u.fill(0); this.v.fill(0); this.w.fill(0); this.density.fill(0); this.temp.fill(0); }

            serialize() {
                return JSON.stringify({
                    d: Array.from(this.density), u: Array.from(this.u), v: Array.from(this.v), w: Array.from(this.w), t: Array.from(this.temp)
                });
            }

            deserialize(json) {
                const data = JSON.parse(json);
                if (data.d) this.density.set(data.d); if (data.u) this.u.set(data.u); if (data.v) this.v.set(data.v); if (data.w) this.w.set(data.w); if (data.t) this.temp.set(data.t);
            }
        }

        let scene, camera, renderer, fluid, densityTexture, material, mesh;
        let GRID_RES = 32;
        let isDragging = false, previousMouseX = 0, previousMouseY = 0, rotationX = 0, rotationY = 0.5, cameraDistance = 1.3;
        let isPaused = false;

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(65, window.innerWidth/window.innerHeight, 0.1, 100);
            updateCameraPosition();

            const canvas = document.createElement('canvas');
            const context = canvas.getContext('webgl2');
            if (!context) {
                alert("浏览器不支持 WebGL2");
                return;
            }
            
            // 关键修改：开启 alpha 以支持透明背景
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                context: context, 
                antialias: true, 
                alpha: true,
                preserveDrawingBuffer: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            // 实时预览显示黑色背景，但清除透明度为 0 以支持透明导出
            renderer.setClearColor(0x000000, 0); 
            document.body.appendChild(renderer.domElement);

            setupSimulator();
            setupInteraction();
            setupControls();
            animate();
        }

        function setupSimulator() {
            if(mesh) scene.remove(mesh);
            if(densityTexture) densityTexture.dispose();
            if(material) material.dispose();

            fluid = new FluidSolver3D(GRID_RES);
            densityTexture = new THREE.Data3DTexture(fluid.density, GRID_RES, GRID_RES, GRID_RES);
            densityTexture.format = THREE.RedFormat;
            densityTexture.type = THREE.FloatType;
            densityTexture.minFilter = THREE.LinearFilter;
            densityTexture.magFilter = THREE.LinearFilter;
            densityTexture.unpackAlignment = 1;

            material = new THREE.ShaderMaterial({
                uniforms: {
                    uDensity: { value: densityTexture },
                    uBaseColor: { value: new THREE.Color(document.getElementById('inp-color').value) },
                    uOpacity: { value: parseFloat(document.getElementById('inp-opacity').value) },
                    uInverseModelMatrix: { value: new THREE.Matrix4() }
                },
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent,
                transparent: true, side: THREE.BackSide, depthWrite: false
            });

            mesh = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), material);
            scene.add(mesh);
            document.getElementById('val-curr-res').innerText = `${GRID_RES}³`;
        }

        function setupInteraction() {
            const canvas = renderer.domElement;
            canvas.addEventListener('mousedown', (e) => { isDragging = true; previousMouseX = e.clientX; previousMouseY = e.clientY; });
            window.addEventListener('mouseup', () => { isDragging = false; });
            window.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const deltaX = e.clientX - previousMouseX, deltaY = e.clientY - previousMouseY;
                rotationX -= deltaX * 0.01; rotationY += deltaY * 0.01;
                rotationY = Math.max(-Math.PI/2.1, Math.min(Math.PI/2.1, rotationY));
                updateCameraPosition();
                previousMouseX = e.clientX; previousMouseY = e.clientY;
            });
            canvas.addEventListener('wheel', (e) => {
                cameraDistance += e.deltaY * 0.001; cameraDistance = Math.max(0.5, Math.min(3.0, cameraDistance));
                updateCameraPosition();
            }, {passive: true});
        }

        function updateCameraPosition() {
            camera.position.x = cameraDistance * Math.sin(rotationX) * Math.cos(rotationY);
            camera.position.z = cameraDistance * Math.cos(rotationX) * Math.cos(rotationY);
            camera.position.y = cameraDistance * Math.sin(rotationY);
            camera.lookAt(0, 0.3, 0);
        }

        function showStatus(text) {
            const msg = document.getElementById('status-msg');
            msg.innerText = text; msg.style.display = 'block';
            setTimeout(() => { msg.style.display = 'none'; }, 2000);
        }

        function setupControls() {
            const bind = (id, obj, prop, labelId) => {
                const el = document.getElementById(id);
                if (!el) return;
                el.addEventListener('input', (e) => {
                    const v = parseFloat(e.target.value);
                    obj[prop] = v;
                    const labelEl = document.getElementById(labelId);
                    if (labelEl) labelEl.innerText = v.toFixed(2);
                });
            };
            
            document.getElementById('inp-res').addEventListener('change', (e) => {
                GRID_RES = parseInt(e.target.value);
                setupSimulator();
                showStatus(`已切换至分辨率 ${GRID_RES}`);
            });

            bind('inp-vort', fluid, 'vorticity', 'lbl-vort');
            bind('inp-buoyancy', fluid, 'buoyancy', 'lbl-buoyancy');
            bind('inp-diff', fluid, 'diffusion', 'lbl-diff');
            bind('inp-turb', fluid, 'turbulence', 'lbl-turb');
            bind('inp-source', fluid, 'sourceIntensity', 'lbl-source');
            bind('inp-opacity', material.uniforms.uOpacity, 'value', 'lbl-opacity');
            bind('inp-fade', fluid, 'fadeRate', 'lbl-fade');
            
            document.getElementById('inp-color').addEventListener('input', e => material.uniforms.uBaseColor.value.set(e.target.value));
            document.getElementById('btn-reset').addEventListener('click', () => { fluid.reset(); showStatus("物理场已清空"); });

            document.getElementById('btn-pause').addEventListener('click', (e) => {
                isPaused = !isPaused;
                e.target.innerText = isPaused ? "继续模拟" : "暂停模拟";
                document.getElementById('val-status').innerText = isPaused ? "暂停中" : "运行中";
            });

            document.getElementById('btn-run-batch').addEventListener('click', (e) => {
                const steps = parseInt(document.getElementById('inp-batch-steps').value) || 1;
                e.target.disabled = true;
                const oldText = e.target.innerText;
                e.target.innerText = "计算中...";
                setTimeout(() => {
                    for(let i=0; i<steps; i++) fluid.step();
                    densityTexture.needsUpdate = true;
                    e.target.disabled = false;
                    e.target.innerText = oldText;
                    showStatus(`完成 ${steps} 步脱机计算`);
                }, 10);
            });

            document.getElementById('btn-export').addEventListener('click', () => {
                const blob = new Blob([fluid.serialize()], {type: "application/json"});
                const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
                a.download = `smoke_state_${GRID_RES}_${Date.now()}.json`; a.click();
                showStatus("导出成功");
            });

            const importTrigger = document.getElementById('btn-import-trigger');
            const fileInput = document.getElementById('inp-import');
            importTrigger.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    try { 
                        fluid.deserialize(ev.target.result); 
                        densityTexture.needsUpdate = true; 
                        showStatus("导入成功"); 
                    } catch(err) { showStatus("导入失败: 格式错误"); }
                };
                reader.readAsText(file);
            });
            
            document.getElementById('btn-capture').addEventListener('click', () => {
                // 截取前确保清空背景透明度
                renderer.setClearAlpha(0);
                renderer.render(scene, camera);
                const dataURL = renderer.domElement.toDataURL("image/png");
                const link = document.createElement('a');
                link.download = `surgical_smoke_transparent_${Date.now()}.png`;
                link.href = dataURL;
                link.click();
                showStatus("透明快照已捕获");
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            const start = performance.now();
            
            if (fluid && !isPaused) {
                fluid.step();
                densityTexture.needsUpdate = true;
            }
            
            const elapsed = performance.now() - start;
            if (document.getElementById('val-ms')) document.getElementById('val-ms').innerText = isPaused ? "0.0" : elapsed.toFixed(1);
            
            let maxD = 0;
            for(let i=0; i<fluid.size; i++) if(fluid.density[i] > maxD) maxD = fluid.density[i];
            if (document.getElementById('val-max-d')) document.getElementById('val-max-d').innerText = maxD.toFixed(1);

            if (mesh) {
                mesh.updateMatrixWorld();
                material.uniforms.uInverseModelMatrix.value.copy(mesh.matrixWorld).invert();
            }
            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>
</html>